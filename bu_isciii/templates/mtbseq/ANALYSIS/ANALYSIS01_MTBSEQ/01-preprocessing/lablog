
# module load fastp

# if assembly pipeline was performed first and the trimmed sequences were saved, this should work:
read -p $'\e[1;37mDid you save the trimmed reads from previous assembly pipeline? [y/N]: \e[1;38;5;220m' -n 1 answer; tput sgr0; echo
    if [ "$answer" == "y" ]; then
        echo "Creating links to trimmed reads..."

        while read in; do
        mkdir ${in}
        cd ${in}
        ln -s ../../../*/01-processing/fastp/${in}_1.fastp.fastq.gz ${in}_R1_filtered.fastq.gz
        ln -s ../../../*/01-processing/fastp/${in}_2.fastp.fastq.gz ${in}_R2_filtered.fastq.gz
        cd -
        done < ../samples_id.txt

        echo -e "\e[32mLinks for $(cat ../samples_id.txt | wc -l) samples succesfully created.\e[0m"
    
    else 
        echo "Preparing _01_fastp.sh file for trimming..."
        
        mkdir logs
        scratch_dir=$(echo $(pwd) | sed 's@/data/bi/scratch_tmp/@/scratch/@g')
        cat ../samples_id.txt | xargs -I @@ echo "mkdir @@; srun --chdir ${scratch_dir} --mem 10G --time 1:00:00 --job-name FP.@@ --output logs/FP.@@.%j.log --partition short_idx --cpus-per-task 5 fastp --in1 ../00-reads/@@_R1.fastq.gz --in2 ../00-reads/@@_R2.fastq.gz --thread 5 --cut_front --cut_tail --cut_mean_quality 15 --qualified_quality_phred 15 --trim_poly_x --length_required 50 --detect_adapter_for_pe --json @@/@@_fastp.json --html @@/@@_fastp.html --out1 @@/@@_R1_filtered.fastq.gz --out2 @@/@@_R2_filtered.fastq.gz --unpaired1 @@/@@_R1_unpaired.fastq.gz --unpaired2 @@/@@_R2_unpaired.fastq.gz &" > _01_fastp.sh

        echo -e "\e[32mFile _01_fastp.sh ready.\e[0m"
        
    fi